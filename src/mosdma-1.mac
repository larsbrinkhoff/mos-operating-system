	.TITLE	MOSNET - MOS NETWORK DEVICE DRIVER ROUTINES

; MOS DEVICE DRIVER FOR THE ACC DMA 1822 INTERFACE.
;
; MODIFIED BY:  BOB BALDWIN	3/1/83
;	ADDED ROUTINES ACCESSED VIA DCT TO RAISE AND
;	LOWER THE HOST READY LINE.
; MODIFIED BY:  RON NATALIE	4/1/83
;	SOME BIS INSTRUCTIONS CHANGED TO MOV.  CHECK FOR RBN IN MARGIN.
; MODIFIED BY:  BOB BALDWIN	5/14/83
;	BOUNDS CHECKING ADDED TO BUFFER ADDRESS.
;


	.INSRT	../moscnf-1.sml
	.INSRT	../mosmac.sml
	.INSRT	../mostbl.sml


	.LIST	ME

	$CNFIG
	.PAGE
	$DFDCT
	.PAGE
	$DFIOR
	.PAGE
	$DFIST

	.NLIST	ME
	.LIST	MEB


	.GLOBL	.DMAOI			;NET OUTPUT INITIALIZE ROUTINE
	.GLOBL	.DMAII			;NET INPUT INITIALIZE ROUTINE
	.GLOBL	.DMAIN			;NET INPUT TRANSFER ROUTINE
	.GLOBL	.DMAOT			;NET OUTPUT TRANSFER ROUTINE
	.GLOBL	DMAINI			;NET INPUT INTERRUPT ROUTINE
	.GLOBL	DMAOTI			;NET OUTPUT INTERRUPT ROUTINE
	.GLOBL	DMARR			;NET RAISE READY LINE ROUTINE
	.GLOBL	DMADR			;NET DROP READY LINE ROUTINE
	.GLOBL	$IOCMP			;I/O COMPLETION EXIT
	.GLOBL	$MDMTP,$MDMBT		;CODE SPACE TOP/BOTTOM


	.SBTTL	ARPANET CONSTANTS
	
	ARMIN = 10			; MINIMUM 80 BIT LEADER
	ARMAX = 1019.			; MAX MSG IN BYTES


	.SBTTL	1822 INTERFACE DEVICE HANDLERS
	.SBTTL	.	SRI/ACC DMA INTERFACE REGISTER ASSIGNMENTS
;
; SRI/ACC DMA 1822 INTERFACE REGISTER ASSIGNMENTS
;

DMRCSR	=	0		; RECEIVE CONTROL STATUS REGISTER
DMRDBR	=	2		; RECEIVE DATA BUFFER REGISTER
DMRCAR	=	4		; RECEIVE CURRENT ADDRESS REGISTER
DMRWCR	=	6		; RECEIVE WORD COUNT REG. (NEG CNT TO 0)
DMRTXB	=	10		; RECEIVE'S REF BIAS TO TX REGISTERS

DMTCSR	=	0		; TRANSMIT CONTROL STATUS REGISTER
DMTDBR	=	2		; TRANSMIT DATA BUFFER REGISTER
DMTCAR	=	4		; TRANSMIT CURRENT ADDRESS REGISTER
DMTWCR	=	6		; TRANSMIT WORD COUNT REG. (NEG CNT TO 0)
DMTRXB	=	-10		; TRANSMIT'S REF BIAS TO RX REGISTERS

; SRI/ACC DMA 1822 RECEIVE CSR BIT ASSIGNMENTS

DMRGO	=	1		; RECEIVE GO, 1=ENABLES DMA TRANSFER
DMRST	=	2		; RESET, 1=CLRS DEV (DROPS HOST RDY LINE)
DMHRLY	=	4		; HOST RELAY CONTROL, 1=RAISE HOST RDY LINE
DMENAB	=	10		; RECEIVE ENABLE, 1=NORMAL DATA TRANSFER
DMRIEN	=	100		; RECV INTERRUPT ENABLE, 1=ENABLED
DMRRDY	=	200		; RECEIVER READY, 1=RECV RDY FOR GO CMND
DMRBF	=	400		; RECEIVE BUFF FULL INDICATOR, FOR DMA USE
DMRYER	=	1000		; RELAY ERR TST, 1=HOST OR IMP RDY LOW
DMIRYO	=	2000		; IMP RELAY OPEN TST, 1=IMP RDY LOW
DMHRYO	=	4000		; HOST RELAY OPEN TST, 1=HOST RDY LOW
DMREOM	=	20000		; RECV END OF MSG TST, 1=RECVD LAST BIT
DMRMTO	=	40000		; RECV MEMORY TIMEOUT, 1=NONEXISTANT MEM REF
DMRERR	=	100000		; RECV ERROR TST, 1=ERR (REFLECTS TIMEOUT ERR)

; SRI/ACC DMA 1822 TRANSMIT CSR BIT ASSIGNMENTS

DMTGO	=	1		; TRANSMIT GO, 1=ENABLES DMA TRANSFER
;DMRST	=	SAME AS RX	; RESET, 1=CLRS DEV (DROPS HOST RDY LINE)
DMLBIT	=	4		; LAST BIT, 1=TX TO SEND LB WHEN WD CNT=0
DMBBAK	=	10		; BUS BACK, 1=CONTROLER LOOPBACK
DMTIEN	=	100		; TRANS INTERUPT ENAB, 1=ENAB INTERUPT
DMTRDY	=	200		; TRANSMIT READY, 1=TX RDY FOR GO CMD
DMTBE	=	400		; TRANSMIT BUFF EMPTY, DMA USE ONLY
;DMRYER	=	SAME AS RX	; RELAY ERROR, 1=HOST OR IMP RDY LOW
DMTMTO	=	40000		; TRAN MEMORY TIMEOUT, 1=NONEXISTANT MEM REF
DMTERR	=	100000		; TRANSMIT ERR, 1=ERR (REFLECTS TIMEOUT ERR)


	.PAGE
	.SBTTL	.	SRI/ACC DMA INTERFACE INITIALIZATION ROUTINES

; SRI/ACC DMA INTERFACE INITIALIZATION ROUTINES
;
;	CALLED WITH:	R2 - ADDRESS OF DCT


$MDMTP:					; GLOBAL SYM FOR TOP OF CODESPACE

.DMAII:					; RECEIVE INIT. ROUTINE
	$PUSH	R1			; SAVE CALLERS REGS
	MOV	DCTLNK(R2),R1		; GET THE TRANS DCT ADDR
	BEQ	10$			; BR IF NO LINKED DCT
	BIT	#DF.INI,DCTFLG(R1)	; CK IF TRANS ALREADY INITED DEV
	BNE	20$			; BR IF INITED
10$:	MOV	DCTCSR(R2),R1		; R1=A(RECV CSR)
	MOV	#DMRST,DMRCSR(R1)	; RESET RECEIVE
	MOV	#DMRST,DMRTXB(R1)	; RESET TRANSMIT
	MOV	#DMADR, DCTDV1(R2)	; PTR TO DROP READY LINE ROUTINE
	MOV	#DMARR, DCTDV2(R2)	; PTR TO RAISE READY LINE ROUTINE
20$:	BIC	#DF.OFL,DCTFLG(R2)	; CLEAR OFF-LINE STATUS
	BIS	#DF.INI,DCTFLG(R2)	; SET INITED STATUS
	$POP	R1			; RESTORE CALLERS REGS
	RTS	PC			; RETURN


.DMAOI:					; TRANSMIT INIT. ROUTINE
	$PUSH	R1			; SAVE CALLERS REGS
	MOV	DCTLNK(R2),R1		; GET THE RECV DCT ADDR
	BEQ	10$			; BR IF NO LINKED DCT
	BIT	#DF.INI,DCTFLG(R1)	; CK IF RECV ALREADY INITED DEV
	BNE	20$			; BR IF INITED
10$:	MOV	DCTCSR(R2),R1		; R1=A(TRANS CSR)
	MOV	#DMRST,DMTRXB(R1)	; RESET RECEIVE
	MOV	#DMRST,DMTCSR(R1)	; RESET TRANSMIT
	MOV	#DMADR, DCTDV1(R2)	; PTR TO DROP READY LINE ROUTINE
	MOV	#DMARR, DCTDV2(R2)	; PTR TO RAISE READY LINE ROUTINE
20$:	BIC	#DF.OFL,DCTFLG(R2)	; CLEAR OFF-LINE STATUS
	BIS	#DF.INI,DCTFLG(R2)	; SET INITED STATUS
	$POP	R1			; RESTORE CALLERS REGS
	RTS	PC			; RETURN


	.PAGE
	.SBTTL	.	SRI/ACC DMA INITIATE RECEIVE TRANSFER ROUTINE

;	CALLED WITH:	R2 - POINTER TO DEVICE CONTROL TABLE (DCT)
;			R0 - POINTER TO INPUT TRANSFER IORB
;
;	RETURNS WITH:	R0 THRU R5 - UNCHANGED

.DMAIN:					; INITIATE RECV TRANS. ROUTINE
	$PUSH	R1,R3			; SAVE CALLERS REGS
	MOV	DCTCSR(R2),R1		; R1=A(RECV CSR)
	BIT	#DMRRDY,DMRCSR(R1)	; CK IF RECV RDY FOR GO CMD
	BNE	10$			; BR IF RDY
	BPT				; BRK PNT IF NOT RDY, SHOULD BE
10$:	BIT	#DMHRYO,DMRCSR(R1)	; CK IF RE-INIT NECESSARY
	BEQ	20$			; BR RE-INIT NOT NECESSARY
	BIS	#DMHRLY!DMENAB,DMRCSR(R1)   ; RAISE HOST RDY LINE
20$:	MOV	DCTBR(R2),R3		; R3=NO. OF BYTES REQUESTED
	CMP	R3,#ARMIN		; LONG ENOUGH?
	BLT	30$
	CMP	R3,#ARMAX		; TOO LONG?
	BGT	30$
	BIT	#1,R3			; WORD XFER?
	BNE	30$
	BIT	#1,DCTUVA(R2)		; WORD ADDRESS?
	BEQ	40$

30$:	BUGHLT	<ARPA INPUT ERROR>

40$:	ASR	R3			; R3=NO. OF WORDS REQUESTED
	NEG	R3			; R3=NEG WORD COUNT
	MOV	R3,DMRWCR(R1)		; NEG WORD COUNT TO WC REG
	MOV	DCTUVA(R2),DMRCAR(R1)	; RECV BUFF ADDRESS TO ADR REG
	MOV	#115,DMRCSR(R1)		; ENAB INTER. AND GO  -RBN
	$POP	R3,R1			; RESTORE CALLERS REGS
	RTS	PC			; RETURN


	.PAGE
	.SBTTL	.	SRI/ACC DMA INITIATE TRANSMIT TRANSFER ROUTINE

;	CALLED WITH:	R2 - POINTER TO DEVICE CONTROL TABLE (DCT)
;			R0 - POINTER TO OUTPUT TRANSFER IORB
;
;	RETURNS WITH:	R0 THRU R5 - UNCHANGED

.DMAOT:					; INITIATE TRANSMIT TRANSFER
	$PUSH	R1,R3			; SAVE CALLERS REGS
	MOV	DCTCSR(R2),R1		; R1=A(TRANS CSR)
	BIT	#DMTRDY,DMTCSR(R1)	; CK IF TRANS RDY FOR GO CMD
	BNE	10$			; BR IF READY
	BPT				; BRK PNT IF NOT READY, SHOULD BE
10$:	BIT	#DMHRYO,DMTRXB(R1)	; CK IF RE-INIT NECESSARY
	BEQ	20$			; BR RE-INIT NOT NECESSARY
	BIS	#DMHRLY!DMENAB,DMTRXB(R1)   ; RAISE HOST RDY LINE
	BIS	#DMRIEN,DMTRXB(R1)	; ENABLE RECEIVE INTERUPTS
20$:	MOV	DCTUVA(R2),R3		; GET PKT BUFFER ADDR
	MOV	R3,DMTCAR(R1)		; TX BUFF ADDR TO ADDR REG
	MOV	DCTBR(R2),R3		; R3=BYTES TO TX
	CMP	R3,#ARMIN		; LONG ENOUGH?
	BLT	30$
	CMP	R3,#ARMAX		; TOO LONG?
	BGT	30$
	BIT	#1,R3			; WORD XFER?
	BNE	30$
	BIT	#1,DCTUVA(R2)		; WORD ADDRESS?
	BEQ	40$

30$:	BUGHLT	<ARPA OUTPUT ERROR>

40$:	ASR	R3			; R3=WORDS TO TX
	NEG	R3			; R3= NEG WORD COUNT TO TX
	MOV	R3,DMTWCR(R1)		; NEG WORD COUNT TO WC REG
	MOV	#105,DMTCSR(R1)		;ENAB INT,LB AND GO    - RBN
	BIT	#DMIRYO,DMTRXB(R1)	; CK IMP RDY LINE STATUS
	BEQ	50$			; BR IF OPEN
	BIS	#DMTRDY,DMTCSR(R1)	; STOP DMA
50$:	$POP	R3,R1			; RESTORE CALLERS REGS
	RTS	PC			; RETURN


	.PAGE
	.SBTTL	.	SRI/ACC DMA 1822 RECEIVE INTERRUPT HANDLER

; SRI/ACC DMA 1822 RECEIVE INTERRUPT HANDLER
;
;	CALLED WITH:	R0 - ADDRESS OF DEVICE CONTROL TABLE
;			(SP) - OLD R0

DMAINI:					; RECEIVE INTERUPT ROUTINE
	$PUSH	R1,R3,R4		; SAVE INTERRUPTED REGS
	MOV	DCTCSR(R0),R1		; R1=A(RECV CSR)
	BIT	#DMRYER,DMRCSR(R1)	; CK IF RDY ERR OCCURED
	BNE	20$			; BR IF ERR
	BIT	#DMREOM,DMRCSR(R1)	; CK IF EOM OCCURED
	BEQ	10$			; BR NO EOM (CONSIDERED ERROR)
	MOV	DCTQH(R0),R4		; R4=A(RECV IORB)
	BEQ	30$			; BR IF NO IORB
	MOV	IRUVA(R4),R3		; GET BUFFER ADDRRESS
	MOV	DMRWCR(R1),R3		; R3=RESIDUAL WC, IF ANY
	ASL	R3			; R3= RESIDUAL BYTE CT
	ADD	DCTBR(R0),R3		; R3=BYTES TRANSFERED
	MOV	R3,IRBX(R4)		; BYTES XFERED TO IORB
	BR	30$			; DONE WITH PROC OF GOOD RX
					; ERROR, DROP RDY LINE
10$:	BIS	#DMRST,DMRCSR(R1)	; RESET RECEIVE
	BIS	#DMHRLY!DMENAB,DMRCSR(R1)  ; RAISE HOST RDY LINE
	BIS	#DMRIEN,DMRCSR(R1)	; ENABLE RECEIVE INTERUPTS
20$:	BIS	#DMRRDY,DMRCSR(R1)	; STOP RECEIVE DMA
	BIS	#DMTRDY,DMRTXB(R1)	; STOP TRANSMIT DMA
	MOV	DCTQH(R0),R4		; R4=A(RECV IORB)
	BEQ	30$			; BR IF NO IORB
	MOV	#I.ERR,IRSTA(R4)	; SET ERROR BIT IN IORB STATUS
30$:	$POP	R4,R3,R1		; RESTORE INTERUPTED REGS
	JMP	$IOCMP			; FINISH I/O ACTIVITY IN MOS


	.PAGE
	.SBTTL	.	SRI/ACC DMA 1822 TRANSMIT INTERRUPT HANDLER


; SRI/ACC DMA 1822 TRANSMIT INTERRUPT HANDLER
;
;	CALLED WITH:	R0 - ADDRESS OF DEVICE CONTROL TABLE
;			(SP) - OLD R0

DMAOTI:					; TRANSMIT INTERUPT ROUTINE
	$PUSH	R1,R3,R4		; SAVE INTERUPTED REGISTERS
	MOV	DCTCSR(R0),R1		; R1=A(TRANS CSR)
	BIC	#DMTIEN,DMTCSR(R1)	; DISABLE TRANS INTERUPTS
	MOV	DMTWCR(R1),R3		; R3=RESIDUAL WORD CNT
	ASL	R3			; R3=RESIDUAL BYTE CNT
	ADD	DCTBR(R0),R3		; R3=BYTES TRANSFERED
	MOV	DCTQH(R0),R4		; R4=A(TRANS IORB)
	MOV	R3,IRBX(R4)		; BYTES TRANSFERED TO IORB
	BIT	#DMRYER,DMTCSR(R1)	; CK IF RDY ERR OCCURED
	BNE	20$			; BR IF ERR
	BIT	#DMTERR,DMTCSR(R1)	; CK IF MEM TIMEOUT ERR OCC.
	BEQ	30$			; BR IF NO ERROR
					; ERROR, DROP RDY LINE
	BIS	#DMRST,DMTCSR(R1)	; RESET TRANSMIT
	BIS	#DMENAB!DMHRLY,DMTRXB(R1)  ; CLOSE THE HOST RDY RELAY
20$:	MOV	#I.ERR,IRSTA(R4)	; SET ERR BIT IN IORB (ACTIVE)
30$:	$POP	R4,R3,R1		; RESTORE INTERUPTED REGS
	JMP	$IOCMP			; FINISH I/O ACTIVITY IN MOS


	.page
	.sbttl	.	SRI/ACC DMA 1822 READY LINE CONTROL ROUTINES

; ACC 1822 RAISE HOST READY LINE
;	CALLED FROM C AS:  DMARR(DCTP)
;			   DCTP - PTR TO INPUT DCT
;
;	CALLED WITH:	2(SP)	- ADDR OF INPUT DCT

DMARR:
	MOV	2(SP),R0
	MOV	DCTCSR(R0),R0		; R0 = ADDR OF INPUT CSR
	BIS	#DMHRLY!DMENAB,(R0)	; RAISE HOST RDY LINE
	BIS	#DMRIEN,(R0)		; ENABLE RECEIVE INTERUPTS
	RTS	PC


; ACC 1822 DROP HOST READY LINE
;	CALLED FROM C AS:  DMADR(DCTP)
;			   DCTP - PTR TO INPUT DCT
;
;	CALLED WITH:	2(SP)	- ADDR OF INPUT DCT

DMADR:
	MOV	2(SP),R0
	MOV	DCTCSR(R0),R0		; R0 = ADDR OF INPUT CSR
	BIC	#DMHRLY,(R0)		; DROP HOST RDY LINE
	BIS	#DMRIEN!DMENAB,(R0)	; MAKE SURE ITS ENABLED
	RTS	PC



$MDMBT:					; GLOBAL SYM FOR BOTTOM OF CODESPACE


	.END
