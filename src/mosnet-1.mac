	.TITLE	MOSNET - MOS NETWORK DEVICE DRIVER ROUTINES
;
;MOS DRIVER FOR THE SRI SERIAL INTERFACE BETWEEN PDP-11'S AND 1822 DEVICES
;
;MODIFIED BY: BOB BALDWIN 1/83,  RETURN I.ERR WHEN IMP DOWN.
;				 NOTE THAT ONLY THE INPUT SIDE CHECKS DUE TO
;				 THE PROBLEMS THAT ARRISE WHEN THE XMIT SIDE
;				 READS THE INBUF REG WHILE INPUT IS OCCURING.
;

	.INSRT	../moscnf-1.sml
	.INSRT	../mosmac.sml
	.INSRT	../mostbl.sml


	.LIST	ME

	$CNFIG
	.PAGE
	$DFDCT
	.PAGE
	$DFIOR
	.PAGE
	$DFIST

	.NLIST	ME
	.LIST	MEB

	.CSECT	MOS

	.GLOBL	.NETOI			;NET OUTPUT INITIALIZE ROUTINE
	.GLOBL	.NETII			;NET INPUT INITIALIZE ROUTINE
	.GLOBL	.NETIN			;NET INPUT TRANSFER ROUTINE
	.GLOBL	.NETOT			;NET OUTPUT TRANSFER ROUTINE
	.GLOBL	NETDR			;NET TOGGLE HOST READY LINE
	.GLOBL	NETRR			;NET TOGGLE HOST READY LINE
	.GLOBL	NETINI			;NET INPUT INTERRUPT ROUTINE
	.GLOBL	NETOTI			;NET OUTPUT INTERRUPT ROUTINE
	.GLOBL	$IOCMP			;I/O COMPLETION EXIT
	.GLOBL	$MNTTP,$MNTBT		;CODE SPACE TOP/BOTTOM



	.SBTTL	1822 INTERFACE DEVICE HANDLERS
	.SBTTL	.	SRI INTERFACE REGISTER ASSIGNMENTS
;
; SRI 1822 INTERFACE REGISTER ASSIGNMENTS
;

; IN THE CSR:
RINTE	=	40			;RECEIVE INTERRUPT ENABLE
TINTE	=	100			;TRANSMIT INTERRUPT ENABLE
RENABL	=	2			;RECEIVE DATA ENABLE
TENABL	=	1			;TRANSMIT DATA ENABLE
; IN CSR+2 (OUTPUT BUFFER)
HSTPWR	=	10000			;CLOSE HOST READY RELAY
HSTCLR	=	20000			;OPEN HOST READY RELAY
; IN CSR+4 (INPUT BUFFER)
IMPMRY	=	10000			;IMP RELAY CK,  0 = CLOSED
HSTMRY	=	20000			;HOST RELAY CK, 0 = CLOSED
IMPODD	=	100000			;IMP WAS DOWN OR LAST BYTE RCV'ED
; IN EITHER BUFFER
LSTBYT	=	4000			;LAST BYTE SENT OR RECEIVED
					;WE SET IT IN CSR+2, CHECK IT IN CSR+4
					

	.PAGE
	.SBTTL	.	SRI INTERFACE INITIALIZATION ROUTINE

;
;	CALLED WITH:	R2 - ADDRESS OF DCT
;
$MNTTP:

.NETOI:
	MOV	#NETDR, DCTDV1(R2)	; SETUP READY LINE OPERATIONS TO
	MOV	#NETRR, DCTDV2(R2)	; DROP AND RAISE HOST LINE
	BIS	#TINTE,@DCTCSR(R2)	; ENABLE TX INTERUPTS
	BIC	#DF.OFL,DCTFLG(R2)	; INDICATE DEVICE ON-LINE
	RTS	PC			; RETURN

.NETII:
	MOV	#NETDR, DCTDV1(R2)	; SETUP READY LINE OPERATIONS TO
	MOV	#NETRR, DCTDV2(R2)	; DROP AND RAISE HOST LINE
1$:	BIS	#RINTE,@DCTCSR(R2)	; ENABLE RX INTERUPTS
	BIC	#DF.OFL,DCTFLG(R2)	; INDICATE DEVICE ON-LINE
	RTS	PC			; RETURN

	.PAGE
	.SBTTL	.	SRI INPUT TRANSFER INITIALIZATION ROUTINE

;
;	CALLED WITH:	R2 - POINTER TO DEVICE CONTROL TABLE (DCT)
;			R0 - POINTER TO INPUT TRANSFER IORB
;
;
;	RETURNS WITH:	R0 THRU R5 - UNCHANGED
;

.NETIN:	BIS	#RENABL,@DCTCSR(R2)	;ALLOW INTERFACE TO ACCEPT DATA
	RTS	PC



	.PAGE
	.SBTTL	.	SRI OUTPUT TRANSFER INITIALIZATION ROUTINE

;
;	CALLED WITH:	R2 - POINTER TO DEVICE CONTROL TABLE (DCT)
;			R0 - POINTER TO OUTPUT TRANSFER IORB
;
;
;
;	RETURNS WITH:	R0 THRU R5 - UNCHANGED
;

.NETOT:
	BIS	#TENABL,@DCTCSR(R2)	;REINIT AND ENABLE OUTPUT REG
	$PUSH	#340			;SIMULATE INTERRUPT
	JSR	PC,DCTIHX(R2)		;TO OUTPUT INTERRUPT ROUTINE
	RTS	PC


	.PAGE
	.SBTTL	.	SRI 1822 INPUT INTERRUPT HANDLER

;
;	CALLED WITH:	R0 - ADDRESS OF DEVICE CONTROL TABLE
;			(SP) - OLD R0
;

NETINI:	$PUSH	R1			;SAVE INTERRUPTED REGISTER
	MOV	@DCTBUF(R0),R1		;GET RECEIVE STATUS & DATA REGISTER
	BMI	2$			;IF UNUSUAL CONDITION, BRANCH
	MOVB	R1,@DCTUVA(R0)		;ELSE, TRANSFER DATA INTO INPUT BUFFER
	DEC	DCTBR(R0)		;DECREMENT THE LENGTH COUNTER
	BLE	1$			;IF TOO MUCH, EXIT & OVERLAY LAST BYTE
	INC	DCTUVA(R0)		;ELSE ADVANCE BUFFER POINTER
1$:	$POP	R1,R0
	$RTT

2$:	BIT	#HSTMRY!IMPMRY,R1	;CK THE MASTER RDY LINES
	BNE	4$			;BR IF EITHER RDY DROPPED
	BIT	#LSTBYT,R1		;CK FOR LAST BYTE INDICATION
	BEQ	4$			;BR IF NOT LAST BYTE--ERROR
	MOVB	R1,@DCTUVA(R0)		;TRANSFER DATA INTO INPT BUFFER
	DEC	DCTBR(R0)		;DECREMENT LENGTH COUNTER
	MOV	DCTQH(R0),R1		;GET POINTER TO CURRENT IORB
	MOV	IRBR(R1),IRBX(R1)	;GET BYTES REQUESTED
	SUB	DCTBR(R0),IRBX(R1)	;SUBTRACT, GETTING PACKET BYTE COUNT
	CLR	IRSTA(R1)		;TRANSFER COMPLETED OK
3$:	BIC	#RENABL,@DCTCSR(R0)	;AND DON'T ALLOW ANY MORE INPUT
	$POP	R1
	JMP	$IOCMP			;AND PERFORM I/O COMPLETION STUFF

4$:	MOV	DCTQH(R0),R1		;GET POINTER TO IORB
	MOV	#I.ERR,IRSTA(R1)	;INDICATE ERROR DURING TRANSFER
	BR	3$			;AND SIGNAL USER



	.PAGE
	.SBTTL	.	SRI 1822 OUTPUT INTERRUPT HANDLER

;
; 	CALLED WITH:	R0 - ADDRESS OF DCT
;
NETOTI:	$PUSH	R1
	CLR	R1
	BISB	@DCTUVA(R0),R1		;MERGE IN OUTPUT DATA
	INC	DCTUVA(R0)		;ADVANCE BUFFER POINTER
	DEC	DCTBR(R0)		;DECREMENT AMOUNT REMAINING
	BGT	1$			;IF POSITIVE, STILL MORE LEFT
	BLT	3$			;IF NEGATIVE, ALL FINISHED, EXIT
	BIS	#LSTBYT,R1		;ELSE, SET LAST BYTE FLAG
1$:	MOV	R1,@DCTBUF(R0)		;MOVE TO XMIT STATUS & DATA REG
	$POP	R1,R0
	$RTT

3$:	MOV	DCTQH(R0),R1		;GET POINTER TO IORB
	MOV	IRBR(R1),IRBX(R1)	;INDICATE ALL BYTES TRANSFERRED
	CLR	IRSTA(R1)		;TRANSFER ASSUMED TO COMPLETED OK
4$:	BIC	#TENABL,@DCTCSR(R0)	;AVOID SPURIOUS INTERRUPT
	$POP	R1
	JMP	$IOCMP			;AND DO I/O COMPLETION STUFF


;SRI 1822 RAISE HOST READY LINE
;	CALLED FROM C AS:  NETRR(DCTP)
;
;	CALLED WITH:	2(SP) - ADDR OF INPUT DCT

NETRR:
	MOV	2(SP), R0		;GET RCT ADDR
	$PUSH	R1			;SAVE CALLER'S REGS
	MOV	DCTCSR(R0), R1		;GET ADDR OF CSR
	MOV	#HSTPWR, 2(R1)		;RAISE READY LINE
	$POP	R1			;RESTORE CALLERS REGS
	RTS	PC


;SRI 1822 DROP HOST READY LINE
;	CALLED FROM C AS:  NETDR(DCTP)
;
;	CALLED WITH:	2(SP) - ADDR OF INPUT DCT

NETDR:
	MOV	2(SP), R0		;GET ADDR OF DCT
	$PUSH	R1			;SAVE CALLER'S REGS
	MOV	DCTCSR(R0), R1		;GET ADDR OF CSR
	MOV	#HSTCLR, 2(R1)		;DROP READY LINE
	$POP	R1			;RESTORE CALLERS REGS
	RTS	PC


$MNTBT:					;END OF CODE HACK

	.END
