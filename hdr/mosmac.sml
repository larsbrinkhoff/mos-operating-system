	.NLIST


	.MACRO	CALL	ADDR
	JSR	PC,ADDR
	.ENDM

	.MACRO	RET
	RTS	PC
	.ENDM	RET


	.MACRO	$PUSH	A1,A2,A3,A4,A5,A6,A7,A8
	.IF B	A1
	.MEXIT
	.ENDC
	MOV	A1,-(SP)
	.IF B	A2
	.MEXIT
	.ENDC
	MOV	A2,-(SP)
	.IF B	A3
	.MEXIT
	.ENDC
	MOV	A3,-(SP)
	.IF B	A4
	.MEXIT
	.ENDC
	MOV	A4,-(SP)
	.IF B	A5
	.MEXIT
	.ENDC
	MOV	A5,-(SP)
	.IF B	A6
	.MEXIT
	.ENDC
	MOV	A6,-(SP)
	.IF B	A7
	.MEXIT
	.ENDC
	MOV	A7,-(SP)
	.IF NB	A8
	.ERROR			;TOO MANY ARGUMENTS TO $PUSH MACRO
	.ENDC
	.ENDM	$PUSH


	.MACRO	$POP	A1,A2,A3,A4,A5,A6,A7,A8
	.IF B	A1
	.MEXIT
	.ENDC
	MOV	(SP)+,A1
	.IF B	A2
	.MEXIT
	.ENDC
	MOV	(SP)+,A2
	.IF B	A3
	.MEXIT
	.ENDC
	MOV	(SP)+,A3
	.IF B	A4
	.MEXIT
	.ENDC
	MOV	(SP)+,A4
	.IF B	A5
	.MEXIT
	.ENDC
	MOV	(SP)+,A5
	.IF B	A6
	.MEXIT
	.ENDC
	MOV	(SP)+,A6
	.IF B	A7
	.MEXIT
	.ENDC
	MOV	(SP)+,A7
	.IF NB	A8
	.ERROR			;TOO MANY ARGUMENTS TO $POP MACRO
	.ENDC
	.ENDM	$POP


	.MACRO	$LOOP	REG,LABEL
	.IF NE	P1103!P1140		;PROCESSOR WITH EXTENDED INSTRUCTIONS?
	SOB	REG,LABEL
	.MEXIT
	.IFF				;IF NOT,
	DEC	REG
	BNE	LABEL
	.ENDC
	.ENDM	$LOOP


	.MACRO	$RTT
	.IF NE P1120
	RTI
	.IFF
	RTT
	.ENDC
	.ENDM


	.MACRO	$GETPS	ARG		;STORE THE PSW
	.IF NE	P1103			;IF LSI-11
	MFPS	ARG
	.IFF				;IF 11/20 OR 11/40
	MOV	@#177776,ARG
	.ENDC
	.ENDM	$GETPS

	.MACRO	$PUTPS	ARG		;STORE THE PSW
	.IF NE	P1103			;IF LSI-11
	MTPS	ARG
	.IFF				;IF 11/20 OR 11/40
	MOV	ARG,@#177776
	.ENDC
	.ENDM	$PUTPS


	.MACRO	$ENABL			;TURN ON INTERRUPTS
	.IF NE	P1103			;IF LSI-11
	MTPS	#0			;TURN ON INTERRUPTS
	.IFF				;IF 11/20 OR 11/40
	BIC	#340,@#177776		;ALLOW INTERRUPTS
	.ENDC
	.ENDM	$ENABL

	.MACRO	$DSABL			;TURN OFF INTERRUPTS
	.IF NE	P1103			;IF LSI-11
	MTPS	#340			;TURN OFF INTERRUPTS
	.IFF				;IF 11/20 OR 11/40
	BIS	#340,@#177776		;MASK OFF INTERRUPTS
	.ENDC
	.ENDM	$DSABL


	.MACRO	$RTTCC
	$GETPS	-(SP)
	BIC	#^C17,(SP)		;LEAVING CONDITION CODE BITS
	BIC	#17,4(SP)		;ZAP RESUME PS CONDITION BITS
	BIS	(SP)+,2(SP)		;MERGE THEM TOGETHER
	$RTT				;AND RETURN
	.ENDM	$RTTCC


	.MACRO	BUGHLT	STRNG
	TRAP				;TRAP TO ERROR HANDLER
	.ASCIZ	/STRNG/			;TEXT OF ERROR MESSAGE
	.EVEN
	.ENDM


	.MACRO	$CVPCT
	JSR	PC,$CVPCT		;CONVERT PID INTO PCT ADDRESS
	.ENDM



	.MACRO	$GTBLK
	JSR	PC,$GTBLK		;GET KERNEL STORAGE BLOCK
	.ENDM

	.MACRO	$RLBLK
	JSR	PC,$RLBLK		;RELEASE KERNEL STORAGE BLOCK
	.ENDM

	.MACRO	$ENQ
	JSR	PC,$ENQ			;PUT ELEMENT ON A QUEUE
	.ENDM

	.MACRO	$DEQ
	JSR	PC,$DEQ			;GET AN ELEMENT FROM HEAD OF THE QUEUE
	.ENDM

	.MACRO	$QDEL
	JSR	PC,$QDEL		;DELETE SPECIFIC ELEMENT FROM THE QUEUE
	.ENDM


;	this sub-macro checks to see if enough
;	aruments were specified

	.MACRO	KRTARG  N,L
	.IF  GE	N-L		;is the no. of arg. req.
				;> or equal to this level?
	.ERROR			;required MACRO argument missing.
	.ENDC
	.ENDM	KRTARG

;	THIS SUB-MACRO GENERATES CODE TO PUT TWO
;	'BYTE ARGUMENTS' INTO A REG.

	.MACRO	GNCD2	H,L,REG
	.IF IDN	L,REG
	  .IF DIF H,REG
	    .IF IDN H,#0
	BIC	#^O177400,REG
	    .MEXIT
	    .IFF
	      .IF IDN H,#1
	BIC	#^O177400,REG
	BIS	#^O400,REG
	      .MEXIT
	      .IFF
	SWAB	REG
	CLRB	REG
	BISB	H,REG
	SWAB	REG
	      .MEXIT
	      .ENDC
	    .ENDC
	  .ENDC
	.IFF
	  .IF IDN L,#0
	    .IF IDN H,REG
	CLRB	REG
	    .MEXIT
	    .IFF
	      .IF IDN H,#0
	CLR	REG
	      .MEXIT
	      .IFF
		.IF IDN H,#1
	MOV	#^O400,REG
		.MEXIT
		.IFF
	CLR	REG
	BISB	H,REG
	SWAB	REG
		.MEXIT
		.ENDC
	      .ENDC
	    .ENDC
	  .IFF
	    .IF IDN L,#1
	      .IF IDN H,REG
	CLRB	REG
	INC	REG
	      .MEXIT
	      .IFF
		.IF IDN H,#0
	MOV	#1,REG
		.MEXIT
		.IFF
		  .IF IDN H,#1
	MOV	#^O401,REG
		  .MEXIT
		  .IFF
	CLR	REG
	BISB	H,REG
	SWAB	REG
	INC	REG
		  .MEXIT
		  .ENDC
		.ENDC
	      .ENDC
	    .IFF
	      .IF IDN H,REG
	CLRB	REG
	BISB	L,REG
	      .MEXIT
	      .IFF
		.IF IDN H,#0
	CLR	REG
	BISB	L,REG
		.MEXIT
		.IFF
		  .IF IDN H,#1
	MOV	#^O400,REG
	BISB	L,REG
		  .MEXIT
		  .IFF
	CLR	REG
	BISB	H,REG
	SWAB	REG
	BISB	L,REG
		  .MEXIT
		  .ENDC
		.ENDC
	      .ENDC
	    .ENDC
	  .ENDC
	.ENDC
	.ENDM	GNCD2

	.MACRO	STK2	A2,A1		; THIS MACRO PUTS TWO ARG IN ONE WORD ON STACK
	.IF NB,	A1
	  .IF NB,  A2
	    .IF IDN	A2,#0
	      .IF IDN	A1,#0
	CLR	-(SP)
	      .IFF
	        .IF IDN	A1,#1
	MOV	#1,-(SP)
		.IFF
	CLR	-(SP)
	MOVB	A1,(SP)
		.ENDC
	      .ENDC
	    .IFF
	      .IF IDN	A2,#1
		.IF IDN	A1,#1
	MOV	#401,-(SP)
		.IFF
	MOV	#400,-(SP)
		  .IF DIF	A1,#0
	MOVB	A1,(SP)
		  .ENDC
		.ENDC
	      .IFF
	CLR	-(SP)
	MOVB	A2,(SP)
	SWAB	(SP)
		.IF IDN		A1,#1
	INC	(SP)
		.IFF
		  .IF DIF	A1,#0
	MOVB	A1,(SP)
		  .ENDC
		.ENDC
	      .ENDC
	    .ENDC
	  .IFF
	.ERROR				; REQUIRED ARG. NOT SPECIFIED
	  .ENDC
	.IFF
	.ERROR				; REQUIRED ARG. NOT SPECIFIED
	.ENDC
	.ENDM	STK2

;	THIS SUB-MACRO PUTS THE SPECIFIED ARGUMENT
;	INTO A REGISTER, IF IT IS NOT ALREADY THERE.

	.MACRO	GNCD	ARG,REG		; GENERATE CODE TO PUT ARG IN REG .
	.IF  DIF REG,ARG		; IS ARG IN THE REG ALREADY?
					;NO, THEN
	  .IF IDN	ARG,#0
	CLR	REG			
	  .IFF
	MOV	ARG,REG			
	  .ENDC
	.ENDC
	.ENDM	GNCD

;	THIS SUB-MACRO PUTS A BYTE ARGUMENT INTO REG.
;	

	.MACRO	GNCDB	ARG,REG		;GEN. CODE TO PUT ARG INTO REG
	.IF  DIF  REG,ARG		;IS ARG IN REG
					;NO,
	CLRB	REG			
	  .IF  DIF  ARG,#0
	    .IF  IDN  ARG,#1
	INCB	REG
	    .IFF
	BISB	ARG,REG			
	    .ENDC
	  .ENDC
	.ENDC
	.ENDM	GNCDB

;	THIS SUB-MACRO CHECKS FOR CONFLICTS IN SPECIFCATIONS OF 
;	ARGUMENTS IN REGISTERS.

	.MACRO	CNFL	ARG,REG		;CHECK FOR CONFLICTING USE OF REGS.
	.IF IDN	REG,ARG			;E.G. IS A0 THE SAME AS REG?
	.ERROR	REG			;CONFLICTING USE OF SPECFIED REGISTER
	.MEXIT
	.ENDC
	.ENDM	CNFL

;	THIS IS THE MAIN SUB-MACRO THAT CALLS THE ABOVE SUB-MACROS.
;	THE OVER ALL EFFECT IS TO GENERATE CODE THAT PUTS THE
;	ARGUMENTS FROM THE MACRO CALLS INTO THE REGISTERS.

	.MACRO	CHKGN	N,A0,A,A1,B,A2,C,A3,D,A4,E	;CHECK AND GEN. CODE
	.IF NB	A0			;IS A0 SPECIFIED?
	  .IF NB  A1			;IS A1 SPECIFIED?
	    .IF NB  A2				;IS A2 SPECIFIED?
	      .IF NB  A3		;IS A3 SPECIFIED?
		.IF NB  A4			;IS A4 SPECIFIED?
		CNFL  A0,R4			;CHECK FOR CONFLICTS
		CNFL  A1,R4			;       "
		CNFL  A2,R4			;	 "
		CNFL  A3,R4			 ;	"
		GNCD'E  A4,R4			;GEN. CODE FOR A4 .
	        .IFF
		KRTARG N,5			;was this arg. req.?
		.ENDC
	      CNFL  A0,R3		;CHECK FOR CONFLICTS
	      CNFL  A1,R3		;	"
	      CNFL  A2,R3		;	"
	      GNCD'D  A3,R3  		;GEN. CODE FOR A3 .
	      .IFF
	      KRTARG N,4		;was this ag. req.?
	      .ENDC
	    CNFL  A0,R2			;CHECK FOR CONFLICTS
	    CNFL  A1,R2			;	"
	    GNCD'C  A2,R2		;GEN. CODE FOR A2 .
	    .IFF
	    KRTARG N,3			;was this arg. req.?
	    .ENDC
	  CNFL  A0,R1			;CHECK FOR CONFLICTS
	  GNCD'B  A1,R1			;GEN CODE A1 .
	  .IFF
	  KRTARG N,2			;was this arg. req.?
	  .ENDC
	GNCD'A  A0,R0			;GEN CODE A0 .
	.IFF
	KRTARG N,1			;was this arg. req.?
	.ENDC
	.ENDM	CHKGN


;	This macro needs to be redone to HALT if KF.DDT is on but
;	MOSDDT is zero. Since it isn't used anywhere in the code,
;	I simply punted. I think the version given here would work,
;	though.
;
;	.MACRO	$ERROR
;	.IF NE	KF.DDT			;IF DEBUGGING W/ DDT
;	.GLOBL	DDT
;	TST	MOSDDT			;IF DDT THERE
;	BEQ	.+6
;	BPT				;PLANT A BREAKPOINT
;	BR	.+4
;	.ENDC
;	HALT				;HALT ON ERROR
;	.ENDM



	.MACRO	$WAIT			;WAIT FOR AN EVENT
	EMT	^O200
	.ENDM	$WAIT



	.MACRO	$WAITS	OP		;WAIT SPECIFIC
	CHKGN	1,OP,B
	EMT	^O201			;ISSUE WAIT SPECIFIC
	.ENDM	$WAITS



	.MACRO	$WAITM	MASK
	CHKGN	1,MASK
	EMT	^O202
	.ENDM	$WAITM



	.MACRO	$SGNLI	PID,EVNTCD,DATA	;SIGNAL BY INTERRUPT ROUTINE
	.NARG	ARGNO.			;ARGNO.=NO. OF ARG SPECIFIED.
	KRTARG	2,ARGNO.		;WAS ENOUGH ARG. SPECIFIED
	CNFL	DATA,R0			;IS THERE A CONFLICT IN REGISTERS
	GNCD2	EVNTCD,PID,R0		;GEN. CODE FOR REG 0
	GNCD	DATA,R1			;PUT DATA INTO R1
	EMT	^O203			;WAKE UP A PROCESS BY INTERRUPT
	.ENDM	$SGNLI



	.MACRO	$SIO	IORBA
	CHKGN	1,IORBA
	EMT	^O204
	.ENDM	$SIO



	.MACRO	$STIME	EVNTCD,DATA,INTRVL	;SET TIMER 
	CHKGN	3,EVNTCD,B,DATA,,INTRVL
	EMT	^O205
	.ENDM	$STIME



	.MACRO	$ITIME	EVNTCD,DATA,INTRVL	;SET TIMER 
	CHKGN	3,EVNTCD,B,DATA,,INTRVL
	EMT	^O206
	.ENDM	$ITIME




	.MACRO	$GETOD
	EMT	^O207
	.ENDM	$GETOD



	.MACRO	$SETOD	HTOD,LTOD	;SET TIME OF DAY
	CHKGN	2,HTOD,,LTOD
	EMT	^O210
	.ENDM	$SETOD


	.MACRO	$AVS	BYTCNT		;ALLOCATE STORAGE (WAIT)
	CHKGN	1,BYTCNT
	EMT	^O211
	.ENDM	$AVS

	.MACRO	$ALS	BYTCNT		; ALLOCATE STORAGE (NO WAIT)
	CHKGN	1,BYTCNT
	EMT	^O234
	.ENDM	$ALS

	.MACRO	$SCK	BYTCNT		; STORAGE CHECK
	CHKGN	1,BYTCNT
	EMT	^O235
	.ENDM	$SCK


	.MACRO	$FVS	BYTCNT,ADDR
	.NARG	ARGNO.
	KRTARG	1,ARGNO.
	CNFL	ADDR,R0
	GNCD	BYTCNT,R0
	GNCD	ADDR,R2
	EMT	^O212
	.ENDM	$FVS



	.MACRO	$GAPID			;GET ACTIVE PROCESS ID
	EMT	^O213
	.ENDM	$GAPID



	.MACRO	$SEMTX	EMTCD,EMTXFR		;SET EMT EXIT
	.NARG	ARGNO.
	KRTARG	1,ARGNO.
	CNFL	EMTCD,R2
	GNCD	EMTXFR,R2
	GNCD	EMTCD,R1
	EMT	^O214
	.ENDM	$SEMTX



	.MACRO	$SEXIT	PID,OPC
	.NARG	ARGNO.			;ARGNO.=NO. OF ARG SPECIFIED.
	KRTARG	1,ARGNO.		;WAS ENOUGH ARG. SPECIFIED
	GNCD2	OPC,PID,R0		;GEN. CODE FOR REG 0
	EMT	^O215
	.ENDM	$SEXIT



	.MACRO	$REXIT	PID
	CHKGN	1,PID,B
	EMT	^O216
	.ENDM	$REXIT



	.MACRO	$GPSTS	PID
	CHKGN	1,PID,B
	EMT	^O217
	.ENDM	$GPSTS



	.MACRO	$GPREG	PID,REG
	.NARG	ARGNO.			;ARGNO.=NO. OF ARG SPECIFIED.
	KRTARG	1,ARGNO.		;WAS ENOUGH ARG. SPECIFIED
	GNCD2	REG,PID,R0		;GEN. CODE FOR REG 0
	EMT	^O220
	.ENDM	$GPREG



	.MACRO	$SPREG	PID,REG,VAL
	.NARG	ARGNO.			;ARGNO.=NO. OF ARG SPECIFIED.
	KRTARG	2,ARGNO.		;WAS ENOUGH ARG. SPECIFIED
	CNFL	VAL,R0			;IS THERE A CONFLICT IN REGISTERS
	GNCD2	REG,PID,R0		;GEN. CODE FOR REG 0
	GNCD	VAL,R1			;PUT DATA INTO R1
	EMT	^O221
	.ENDM	$SPREG


	.MACRO	$THAWP	PID
	CHKGN	1,PID,B
	EMT	^O222
	.ENDM	$THAWP



	.MACRO	$SUSPR	PID
	CHKGN	1,PID,B
	EMT	^O223
	.ENDM	$SUSPR


	.MACRO	$SIN	BUF,LEN
	CHKGN	2,BUF,,LEN
	EMT	^O224
	.ENDM	$SIN



	.MACRO	$SOUT	BUF,LEN
	CHKGN	2,BUF,,LEN
	EMT	^O225
	.ENDM	$SOUT


	.MACRO	$BIN
	EMT	^O226
	.ENDM	$BIN



	.MACRO	$BOUT	BYT
	CHKGN	1,BYT,B
	EMT	^O227
	.ENDM	$BOUT


	.MACRO	$SPRIO	PID,PRI,PRO
	CHKGN	3,PID,B,PRI,,PRO
	EMT	^O230
	.ENDM	$SPRIO


	.MACRO	$STI	DEV,BYT
	CHKGN	2,DEV,,BYT,B
	EMT	^O231
	.ENDM	$STI
	

	.MACRO	$GPNAM	PID
	CHKGN	1,PID,B
	EMT	^O232
	.ENDM	$GPNAM



	.MACRO	$MSTAT
	EMT	^O233
	.ENDM	$MSTAT




;NOTE:	FOLLOWING MACRO DOES NOT SET V BIT AS DESCRIBED IN PDP 11/45 HANDBOOK
	.MACRO	$ASH COUNT,REG
	.IF NE P11E			;IF PROC WITH EIS
	  .IFT				;  THEN DO;
	    .IF GT COUNT		;    IF COUNT > 0
	      .IFT			;      THEN DO;
	        .IF GT COUNT-^D2	;        IF COUNT > 2
	          .IFT			;          THEN DO;
	ASH	#COUNT,REG    		;PERFORM REQUESTED SHIFT
	          .IFTF			;            END;
	          .IFF			;          ELSE DO;
	            .REPT COUNT		;            THRU COUNT DO;
	ASL	REG			;SHIFT ONE BIT LEFT
	            .ENDR		;              END;
	          .ENDC			;            END;
	      .IFF			;      ELSE DO;
	        .IF LT COUNT+^D2	;        IF COUNT < -2
	          .IFT			;          THEN DO;
	ASH	#COUNT,REG    		;PERFORM REQUESTED SHIFT
	          .IFTF			;            END;
	          .IFF			;          ELSE DO;
	            .REPT -COUNT 	;            THRU -COUNT DO;
	ASR	REG			;SHIFT ONE BIT RIGHT
	            .ENDR		;              END;
	          .ENDC			;            END;
	      .ENDC			;        END;
	    .IFTF			;    END;
	  .IFF				;  ELSE DO;
	    .IF GT COUNT		;    IF COUNT > 0
	      .IFT			;      THEN DO;
	        .IF GE COUNT-^D8	;        IF COUNT >=8
	          .IFT			;          THEN DO;
	            .IF EQ COUNT-^D8 	;            IF COUNT = 8
	              .IFT		;              THEN DO;
	SWAB	REG			;SWAP HIGH AND LOW BYTES
	ASRB	REG			;SET CARRY BIT
	BICB	REG,REG			;CLEAR LOW BYTE W/O CLEARING CARRY BIT
	                $ASCNT = ^D0 	;                AS_COUNT = 0;
	              .IFTF		;                END;
	              .IFF		;              ELSE DO;
	SWAB	REG			;SWAP HIGH AND LOW BYTES
	CLRB	REG			;CLEAR LOW BYTE
	                $ASCNT=COUNT-^D8;                AS_COUNT = COUNT - 8;
	              .ENDC		;                END;
	          .IFTF			;            END;
	          .IFF			;          ELSE DO;
	            $ASCNT = COUNT 	;            AS_COUNT = COUNT;
	          .ENDC			;            END;
	        .REPT $ASCNT		;        THRU AS_COUNT DO;
	ASL	REG			;SHIFT LEFT ONE BIT
	        .ENDR			;          END;
	      .IFTF			;        END;
	      .IFF			;      ELSE DO;
	        .IF LT COUNT+^D8	;        IF COUNT < -8
	          .IFT			;          THEN DO;
	CLRB	REG			;CLEAR LOW BYTE
	SWAB	REG			;SWAP HIGH AND LOW BYTE
	            $ASCNT = -COUNT-^D8	;            AS_COUNT = -COUNT - 8;
	          .IFTF			;            END;
	          .IFF			;          ELSE DO;
	            $ASCNT = -COUNT 	;            AS_COUNT = -COUNT;
	          .ENDC			;            END;
	        .REPT $ASCNT		;        THRU AS_COUNT DO;
	ASR	REG			;SHIFT RIGHT ONE BIT
	        .ENDR			;          END;
	      .ENDC			;        END;
	    .ENDC			;    END;
	.ENDM	$ASH



;NOTE:	FOLLOWING MACRO DOES NOT SET N,V, OR Z BITS AS DESCRIBED IN PDP 11/45 MANUAL
	.MACRO	$ASHC	COUNT,REG
	.IF NE P11E			;IF PROC WITH EIS
	  .IFT				;  THEN DO;
	ASHC	#COUNT,REG     		;PERFORM REQUESTED SHIFT
	  .IFTF				;    END;
	  .IFF				;  ELSE DO;
	    .IF LT COUNT		;    IF COUNT < 0
	      .IFT			;      THEN DO;
	        .REPT -COUNT		;        THRU -COUNT DO;
	ASR	REG 			;SHIFT HIGH REGISTER RIGHT ONE BIT
	ROR	REG+1 			;SHIFT LOW REGISTER RIGHT ONE BIT
		.ENDR			;          END;
	      .IFTF			;        END;
	      .IFF			;      ELSE DO;
	        .REPT COUNT		;        THRU COUNT DO;
	ASL	REG+1 			;SHIFT LOW REGISTER LEFT ONE BIT
	ROL	REG 			;SHIFT HIGH REGISTER LEFT ONE BIT
	        .ENDR			;           END;
	    .ENDC			;         END;
	  .ENDC				;    END;
	.ENDM	$ASHC


	.LIST
