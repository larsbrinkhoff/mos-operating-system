	.TITLE	MOSGEN - GENERATION OF PROCESS, DEVICE AND STORAGE TABLES

	$CNFIG
	$DFIOR
	$DFPCT
	$DFDEV
	$DFDCT

	.GLOBL	$PCTVT, PCTVT		;PCT VECTOR TABLE
	.GLOBL	$DCTVT, DCTVT		;DEVICE CONTROL TABLE VECTOR TABLE
	.GLOBL	$MEMDT			;MEMORY DESCRIPTOR TABLE
	.GLOBL	$BLKPL, NKBLKS		;KERNEL BLOCK POOL

	.CSECT	MOSDAT, STATIC



	.SBTTL	PROCESS DESCRIPTOR TABLE

	.MACRO	PCT	ENTRY,NAME,CAP,PRI,PRO

; ENTRY - PROCESS START POINT
; NAME - NAME (SIX ASCII CHARACTERS)
; CAP - CAPABILITIES (IF ANY)
; PRI - PRIMARY INPUT DEVICE (IF ANY)
; PRO - PRIMARY OUTPUT DEVICE (IF ANY)

	NPCTS = NPCTS+1			;BUMP NUMBER OF PCTS ALLOCATED
	.IF GT, NPROCS-NPCTS
	PCLNK = NPCTS+1
	.IFF
	.IF EQ, NPROCS-NPCTS
	PCLNK = 1
	.IFF
	.ERROR	NPROCS			;TOO MANY PROCESSES SPECIFIED
	.ENDC
	.ENDC
	DFPCT	\NPCTS,\PCLNK,ENTRY,NAME,CAP,PRI,PRO
	.ENDM	PCT


	.MACRO	DFPCT	PCN,LNK,ENTRY,NAME,CAP,PRI,PRO

; PCN - PROCESS NUMBER (KLUDGE TO USE AS SYMBOL)
; LNK - PROCESS NUMBER FOR CIRCULAR LIST LINKAGE

	.GLOBL	ENTRY			;PROCESS START ADDRESS
	.CSECT	MOSPCT, STATIC
	..TMP = .
.PCT'PCN:
	.CSECT	MOSDAT, STATIC
	.WORD	..TMP
	.CSECT	MOSPCT, STATIC
	.WORD	.PCT'LNK
	.BYTE	PCN
	.BYTE	0
	.IF NB,	CAP
	.WORD	CAP			;REMEMBER CAPABILITIES IF SPECIFIED
	.IFF
	.WORD	0			;CAPABILITIES DEFAULT TO NONE (0)
	.ENDC
	.BLKB	PCTENT-PCTFLG-2		;ALLOCATE SPACE BEFORE ENTRY POINT WORD
	.WORD	ENTRY			;REMEMBER PROCESS START ADDRESS
	..TMP = .
	.ASCII	/NAME/			;PROCESS NAME
	.IF NE,	.-..TMP-PCTNLN
	.ERROR	NAME			;NAME NOT 6 CHARACTERS LONG
	.ENDC
	.IF NB,	PRI
	.WORD	PRI			;DEFAULT PRIMARY INPUT DEVICE
	.IFF
	.WORD	0			;NO DEFAULT INPUT DEVICE
	.ENDC
	.IF NB,	PRO
	.WORD	PRO			;DEFAULT PRIMARY OUTPUT DEVICE
	.IFF
	.WORD	0			;NO DEFAULT OUTPUT DEVICE
	.ENDC
	.BLKB	PCTLEN-PCTDPO-2		;ALLOCATE REST OF PCT
	.CSECT	MOSDAT, STATIC
	.ENDM	DFPCT


$PCTVT:
PCTVT:	.WORD	0			;SPACE FOR NUMBER OF PCTS

	NPCTS = 0					;RESET PCT COUNTER
	$PCON				;DEFINE PROCESS CONFIGURATION

	..TMP = .			;GO BACK AND SET NUMBER OF PCTS
	. = $PCTVT
	.WORD	NPCTS
	. = ..TMP	



	.SBTTL	DEVICE DESCRIPTOR TABLE

	.MACRO	DCT	NUM,INA,DVA,IHA,IVA,CSR,BUF,LNK

; DV.TYP - DEVICE TYPE
; DV.BAS - DEVICE BASE NUMBER
; NUM - DEVICE UNIT NUMBER
; INA - DEVICE/DRIVER INITIALIZATION ROUTINE ADDRESS
; DVA - DRIVER TRANSFER INITIATION ADDRESS
; IHA - DEVICE INTERRUPT HANDLER ADDRESS
; IVA - DEVICE INTERRUPT VECTOR ADDRESS
; CSR - DEVICE COMMAND/STATUS REGISTER ADDRESS
; BUF - DEVICE DATA BUFFER REGISTER ADDRESS
; LNK - DCT UNIT NUMBER OF 'LINKED' DCTS

	DVNUM = DV.BAS+NUM
	.IF NB,	LNK
	DVLNK = DV.BAS+LNK
	.IFF
	DVLNK = DVNUM
	.ENDC
	DFDCT	\DVNUM,NUM,INA,DVA,IHA,IVA,CSR,BUF,\DVLNK
	.ENDM	DCT


	.MACRO	DFDCT	DVN,NUM,INA,DVA,IHA,IVA,CSR,BUF,LNK

; DVN - SYSTEM DEVICE NUMBER (KLUDGE TO USE AS LABEL)

	.GLOBL	INA			;DRIVER INITIALIZATION ADDRESS
	.IF NB,	DVA
	.GLOBL	DVA			;DRIVER TRANSFER INIT ROUTINE
	.ENDC
	.IF NB,	IHA
	.GLOBL	IHA			;DEVICE INTERRUPT HANDLER
	.ENDC
NDCTS	=	NDCTS+1			;BUMP NUMBER OF DCTS DEFINED
	.IF NE,	DVN-NDCTS
	.ERROR				;DCTS SPECIFIED OUT OF ORDER
	.ENDC
	.CSECT	MOSDCT, STATIC
	JSR	%0,@(%7)+		;BRANCH TO INTERRUPT HANDLER
	.WORD	IHA			;ADDRESS OF INTERRUPT HANDLER
	..TMP = .
.DCT'DVN:				;LABEL FOR DCT
	.CSECT	MOSDAT, STATIC
	.WORD	..TMP			;ADDR OF DCT IN DCTVT
	.CSECT	MOSDCT, STATIC
	.BLKB	DCTLNK
	.IF NB,	LNK
	  .WORD	.DCT'LNK		;ADDRESS OF LINKED DCT
	  .IFF
	  .WORD	..TMP			;IF NO LINK, POINT TO OURSELVES
	.ENDC
	.WORD	IVA			;INTERRUPT VECTOR ADDRESS
	.WORD	INA			;DRIVER INITIALIZATION ROUTINE
	.WORD	CSR			;DEVICE COMMAND/STATUS REG ADDR
	.IF NB,	BUF
	  .WORD	BUF			;DEVICE DATA BUFFER REG ADDRESS
	  .IFF
	  .WORD	CSR+2			;DEVICE DATA BUFFER REG ADDRESS
	.ENDC
	.WORD	DVA			;ADDRESS OF TRANSFER ROUTINE
	.WORD	DVN			;SYSTEM DEVICE NUMBER
	.WORD	NUM			;DEVICE NUMBER IN CLASS
	.BLKB	DCTBLN-DCTDVA-2		;ALLOCATE REST OF DCT
	.IF EQ,	DV.TYP-TTY
	.BLKB	DCTTLN-DCTBLN		;ALLOCATE TTY SPECIFIC PART OF DCT
	.ENDC
	.CSECT	MOSDAT, STATIC
	.ENDM	DFDCT


$DCTVT:
DCTVT:	.WORD	0			;NUMBER OF DCTS ALLOCATED

	NDCTS = 0			;INIT DCT COUNTER
	$IOCON				;DEFINE I/O CONFIGURATION

	..TMP = .
	. = $DCTVT
	.WORD	NDCTS			;DEFINE NUMBER OF DCTS ALLOCATED
	. = ..TMP



	.SBTTL	STORAGE DESCRIPTOR TABLE


	.MACRO	$DFPL	SIZ		;DEFINE STORAGE POOL
	.IF GT,	..TMP-SIZ		;IF NOT DECLARED IN ASCENDING ORDER
	.ERROR	SIZ			;POOLS MUST BE IN ASCENDING ORDER
	.ENDC
	..TMP = SIZ			;REMEMBER LAST SIZE
	.WORD	SIZ			;SIZE OF EACH BUFFER
	.WORD	0			;LIST POINTER
	.ENDM


$MEMDT:					;STORAGE DESCRIPTOR TABLE

	..TMP = 0
	$SCON
	.WORD	0			;END TABLE W/ LENGTH OF ZERO



	.SBTTL	KERNEL STORAGE BLOCK POOL


NKBLKS:	.WORD	NBLKS			;YADDA-YADDA, WARDEN, YADDA-YADDA
$BLKPL:	.BLKB	BLKLEN*NBLKS		;POOL SPACE

	.EVEN
